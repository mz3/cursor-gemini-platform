name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Stage 1: Build and Push Containers
  build-containers:
    runs-on: ubuntu-latest
    outputs:
      api-image: ${{ steps.meta-api.outputs.tags }}
      ui-image: ${{ steps.meta-ui.outputs.tags }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for API
        id: meta-api
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/platform-api
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Extract metadata for UI
        id: meta-ui
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}/platform-ui
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Build and push API image
        uses: docker/build-push-action@v5
        with:
          context: ./platform-api
          file: ./platform-api/Dockerfile
          push: true
          tags: ${{ steps.meta-api.outputs.tags }}
          labels: ${{ steps.meta-api.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build and push UI image
        uses: docker/build-push-action@v5
        with:
          context: ./platform-ui
          file: ./platform-ui/Dockerfile
          push: true
          tags: ${{ steps.meta-ui.outputs.tags }}
          labels: ${{ steps.meta-ui.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # Stage 2: Unit Tests (Parallel)
  unit-tests-api:
    runs-on: ubuntu-latest
    needs: [build-containers]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'npm'
          cache-dependency-path: platform-api/package-lock.json

      - name: Install API dependencies
        run: npm ci
        working-directory: ./platform-api

      - name: Check API TypeScript compilation
        run: npx tsc --noEmit
        working-directory: ./platform-api

      - name: Run API unit tests
        run: npm run test:unit
        working-directory: ./platform-api

  unit-tests-ui:
    runs-on: ubuntu-latest
    needs: [build-containers]
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'npm'
          cache-dependency-path: platform-ui/package-lock.json

      - name: Install UI dependencies
        run: npm ci
        working-directory: ./platform-ui

      - name: Check UI TypeScript compilation
        run: npx tsc --noEmit
        working-directory: ./platform-ui

      - name: Build UI
        run: npm run build
        working-directory: ./platform-ui

      - name: Run UI unit tests
        run: npm test
        working-directory: ./platform-ui

  # Stage 3: API Integration Tests
  api-integration-tests:
    runs-on: ubuntu-latest
    needs: [build-containers, unit-tests-api]
    services:
      postgres:
        image: postgres:14-alpine
        env:
          POSTGRES_USER: platform_user
          POSTGRES_PASSWORD: platform_password
          POSTGRES_DB: platform_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5433:5432

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull API image
        run: docker pull ${{ needs.build-containers.outputs.api-image }}

      - name: Wait for PostgreSQL
        run: |
          until pg_isready -h localhost -p 5433 -U platform_user; do
            echo "Waiting for PostgreSQL..."
            sleep 2
          done

      - name: Start API container
        run: |
          docker run -d \
            --name platform-api-test \
            -p 4000:4000 \
            -e NODE_ENV=test \
            -e DB_HOST=host.docker.internal \
            -e DB_PORT=5433 \
            -e DB_USER=platform_user \
            -e DB_PASSWORD=platform_password \
            -e DB_NAME=platform_db \
            -e REDIS_HOST=host.docker.internal \
            -e REDIS_PORT=6379 \
            -e JWT_SECRET=test-jwt-secret-key \
            -e API_PORT=4000 \
            --add-host=host.docker.internal:host-gateway \
            ${{ needs.build-containers.outputs.api-image }}

      - name: Verify API server is running
        run: |
          echo "Checking if API server is responding..."
          until curl -f http://localhost:4000/health; do
            echo "Waiting for API server..."
            sleep 2
          done
          echo "API server is ready!"

      - name: Run API integration tests
        run: |
          echo "Running API integration tests..."
          cd platform-api
          npm ci
          npm run test:integration
        env:
          NODE_ENV: test
          DB_HOST: localhost
          DB_PORT: 5433
          DB_USER: platform_user
          DB_PASSWORD: platform_password
          DB_NAME: platform_db
          REDIS_HOST: localhost
          REDIS_PORT: 6379
          JWT_SECRET: test-jwt-secret-key
          API_PORT: 4000

      - name: Test API login with test credentials
        run: |
          echo "Testing API login with test credentials..."
          # Test login endpoint
          response=$(curl -s -w "\n%{http_code}" -X POST http://localhost:4000/api/users/login \
            -H "Content-Type: application/json" \
            -d '{"email":"admin@platform.com","password":"admin123"}')

          http_code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n -1)

          echo "Login response status: $http_code"
          echo "Login response body: $body"

          if [ "$http_code" -eq 200 ]; then
            echo "✅ Login test passed!"
            # Extract token for further testing
            token=$(echo "$body" | grep -o '"token":"[^"]*"' | cut -d'"' -f4)
            echo "Token extracted: ${token:0:20}..."

            # Test user profile endpoint
            profile_response=$(curl -s -w "\n%{http_code}" -X GET http://localhost:4000/api/users/profile \
              -H "Authorization: Bearer $token")

            profile_http_code=$(echo "$profile_response" | tail -n1)
            profile_body=$(echo "$profile_response" | head -n -1)

            echo "Profile response status: $profile_http_code"
            echo "Profile response body: $profile_body"

            if [ "$profile_http_code" -eq 200 ]; then
              echo "✅ Profile test passed!"
            else
              echo "❌ Profile test failed!"
              exit 1
            fi
          else
            echo "❌ Login test failed!"
            exit 1
          fi

      - name: Cleanup API container
        if: always()
        run: docker stop platform-api-test || true && docker rm platform-api-test || true

  # Stage 4: E2E Tests
  e2e-tests:
    runs-on: ubuntu-latest
    needs: [build-containers, unit-tests-api, unit-tests-ui, api-integration-tests]
    services:
      postgres:
        image: postgres:14-alpine
        env:
          POSTGRES_USER: platform_user
          POSTGRES_PASSWORD: platform_password
          POSTGRES_DB: platform_db
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5433:5432

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'npm'
          cache-dependency-path: platform-ui/package-lock.json

      - name: Install UI dependencies
        run: npm ci
        working-directory: ./platform-ui

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull API and UI images
        run: |
          docker pull ${{ needs.build-containers.outputs.api-image }}
          docker pull ${{ needs.build-containers.outputs.ui-image }}

      - name: Wait for PostgreSQL
        run: |
          until pg_isready -h localhost -p 5433 -U platform_user; do
            echo "Waiting for PostgreSQL..."
            sleep 2
          done

      - name: Start API container
        run: |
          docker run -d \
            --name platform-api-e2e \
            -p 4000:4000 \
            -e NODE_ENV=test \
            -e DB_HOST=host.docker.internal \
            -e DB_PORT=5433 \
            -e DB_USER=platform_user \
            -e DB_PASSWORD=platform_password \
            -e DB_NAME=platform_db \
            -e REDIS_HOST=host.docker.internal \
            -e REDIS_PORT=6379 \
            -e JWT_SECRET=test-jwt-secret-key \
            -e API_PORT=4000 \
            --add-host=host.docker.internal:host-gateway \
            ${{ needs.build-containers.outputs.api-image }}

      - name: Start UI container
        run: |
          docker run -d \
            --name platform-ui-e2e \
            -p 3000:3000 \
            -e NODE_ENV=test \
            ${{ needs.build-containers.outputs.ui-image }}

      - name: Verify API server is running
        run: |
          echo "Checking if API server is responding..."
          until curl -f http://localhost:4000/health; do
            echo "Waiting for API server..."
            sleep 2
          done
          echo "API server is ready!"

      - name: Verify UI server is running
        run: |
          until curl -f http://localhost:3000; do
            echo "Waiting for UI server..."
            sleep 2
          done
          echo "UI server is ready!"

      - name: Run E2E tests
        run: npm run test:e2e:local
        working-directory: ./platform-ui
        env:
          CYPRESS_baseUrl: http://localhost:3000
          CYPRESS_apiUrl: http://localhost:4000
          CYPRESS_testEmail: admin@platform.com
          CYPRESS_testPassword: admin123

      - name: Upload E2E screenshots (on failure)
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: cypress-screenshots
          path: platform-ui/cypress/screenshots/
          if-no-files-found: ignore

      - name: Upload E2E videos (on failure)
        uses: actions/upload-artifact@v4
        if: failure()
        with:
          name: cypress-videos
          path: platform-ui/cypress/videos/
          if-no-files-found: ignore

      - name: Cleanup containers
        if: always()
        run: |
          docker stop platform-api-e2e platform-ui-e2e || true
          docker rm platform-api-e2e platform-ui-e2e || true
