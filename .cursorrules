# Cursor Rules for Full-Stack Feature Implementation

## Project Backlog and Task Management

### Notion Backlog Integration
- **Primary Backlog**: [Software Backlog](https://www.notion.so/23fff2c597af80328ea0c6dd02467973?v=23fff2c597af8036aa05000c95b4831e&source=copy_link)
- **Database ID**: `23fff2c597af80328ea0c6dd02467973`
- **Board Type**: Kanban with columns: Backlog, In Progress, Review, Done

### Notion CLI Usage
- **CLI Location**: `/cli` directory in project root
- **Authentication**: Configure `cli/.env` with Notion integration token
- **Commands**:
  ```bash
  cd cli
  npm run dev create                    # Interactive task creation
  npm run dev create -- --title "Task" # Command-line task creation
  npm run dev info                      # Show database information
  ```
- **Task Creation Examples**:
  ```bash
  npm run dev create -- --title "Fix login bug" --status "In Progress" --priority "High"
  npm run dev create -- --title "Add user authentication" --description "Implement JWT auth" --tags "backend,security"
  ```

### Task Management Workflow
1. **Create tasks** using CLI when starting new work
2. **Update status** manually in Notion as work progresses
3. **Use tags** for categorization (backend, frontend, bug, feature, etc.)
4. **Set priority** based on business impact and urgency

## Full-Stack Feature Pattern

When implementing a new full-stack feature (like the Bot feature), follow this comprehensive pattern:

### Backend Implementation (API)
1. **Create TypeORM Entity** in `api/src/entities/` with proper relationships
2. **Create Database Migration** in `api/src/migrations/` with timestamp prefix
3. **Create API Routes** in `api/src/routes/` with full CRUD operations:
   - GET /api/[resource] - List all
   - GET /api/[resource]/:id - Get specific
   - POST /api/[resource] - Create new
   - PUT /api/[resource]/:id - Update
   - DELETE /api/[resource]/:id - Delete
4. **Update Database Config** to include new entity
5. **Register Routes** in `api/src/index.ts`
6. **Run Migration** with `npm run migration:run`

### Frontend Implementation (React)
1. **Create List Component** in `webapp/src/components/` (e.g., `[Resource]s.tsx`)
2. **Create Form Component** for create/edit operations
3. **Create Individual Components**:
   - `Create[Resource].tsx` - Create new
   - `Edit[Resource].tsx` - Edit existing
   - `View[Resource].tsx` - View details
4. **Update App.tsx** with routes and navigation
5. **Add to Navigation Menu** with appropriate icon

### Testing Pattern
1. **Test API Endpoints** with curl commands
2. **Verify Database** with direct queries
3. **Test Frontend** by accessing webapp
4. **Verify CRUD Operations** work end-to-end

### File Organization
- All Docker files in `docker/` folder
- All deployment files in `deploy/` folder
- API runs on port 4000
- UI runs on port 3000 (served by Nginx)
- Database on port 5433
- Redis on port 6379

### Development Environment
- Use `docker-compose up --build` to start local dev
- API container auto-rebuilds on code changes
- Frontend has hot reload via Vite
- Database migrations run automatically

### Bot Feature Specific Notes
- Bots have many-to-many relationship with Prompts
- Bot entity includes: name, displayName, description, isActive, userId
- Frontend includes prompt selection in BotForm
- All CRUD operations tested and working
